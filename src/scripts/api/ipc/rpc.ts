// This file is automatically generated by the SimplyDMX plugin framework.
// Please do not edit it manually.

import { callService } from "./agnostic_abstractions";


/**
 * Represents the abstract data for a single light in a layer.
 * A value's binary may be masked if the output is u8 (integer overflow cast)
 */
export type AbstractLayerLight = Record<string, BlenderValue>;

/**
 * Value to be used in a submaster with instructions for mixing it into the result
 */
export type BlenderValue = "None" | { Static: number } | { Offset: number };

/**
 * This contains data that indicates how a channel should be blended.
 * 
 * It is provided by the fixture description to tweak the properties of a layer's blending function.
 */
export interface BlendingData {
    scheme: BlendingScheme;
    snap: SnapData;
    allow_wrap: boolean;
    max_value: number;
    min_value: number;
}

/**
 * The method in which conflicts are resolved while blending
 */
export type BlendingScheme = "HTP" | "LTP";

/**
 * Information about a specific channel available on the fixture
 */
export interface Channel {
    size: ChannelSize;
    default?: number;
    ch_type: ChannelType;
}

/**
 * Dictates the size of the output. Values will be stored as the largest of these options, but bounds
 * will be enforced by the UI, mixer, and output will be truncated.
 */
export type ChannelSize = "U8" | "U16";

/**
 * Describes information used for controlling and blending the channel
 */
export type ChannelType = { Segmented: { segments: Segment[]; priority: BlendingScheme; snapping: SnapData | null } } | { Linear: { priority: BlendingScheme } };

/**
 * An error that could occur when creating a fixture
 */
export type CreateFixtureError = "FixtureTypeMissing" | "ControllerMissing" | { ErrorFromController: CreateInstanceError };

/**
 * A generic error originating from an OutputDriver interface when creating a fixture instance
 */
export type CreateInstanceError = { InvalidData: string } | { Other: string };

/**
 * A description for a DMX driver
 */
export interface DMXDriverDescription {
    name: string;
    description: string;
    id: string;
}

/**
 * DMX-specific components of a fixture definition.
 * 
 * This goes in the output_info, property of a `FixtureBundle` object
 */
export interface DMXFixtureData {
    personalities: Record<string, DMXPersonalityData>;
}

/**
 * This holds DMX-specific information about a fixture instance
 */
export interface DMXFixtureInstance {
    universe: Uuid | null;
    offset: number | null;
}

/**
 * An error that could occur while initializing the DMX plugin
 */
export type DMXInitializationError = "UnrecognizedData";

/**
 * DMX-specific personality data
 * 
 * This goes inside a `DMXFixtureData` instance
 */
export interface DMXPersonalityData {
    dmx_channel_order: string[];
}

/**
 * The DMX portion of the show file
 */
export interface DMXShowSave {
    library: Record<Uuid, DMXFixtureData>;
    fixtures: Record<Uuid, DMXFixtureInstance>;
    universes: Record<Uuid, UniverseInstance>;
}

/**
 * Minified representation of a DMX driver for display
 */
export interface DisplayableDMXDriver {
    id: string;
    name: string;
    description: string;
}

/** Describes a value to be shown in a dropdown list */
export interface DropdownOptionJSON {
    name: string;
    description: string | null;
    value: Value;
}

/**
 * The E131 portion of the show file
 */
export interface E131DMXShowSave {
    universes: Record<Uuid, E131Universe>;
}

/**
 * An error that could occur while initializing the E131 plugin
 */
export type E131InitializationError = "UnrecognizedData";

/**
 * E131-specific DMX universe data
 */
export interface E131Universe {
    external_universe: number;
}

/**
 * An error that could occur when creating a fixture
 */
export type EditFixtureError = "FixtureMissing" | "FixtureTypeMissing" | "ControllerMissing" | { ErrorFromController: EditInstanceError };

/**
 * A generic error originating from an OutputDriver interface when editing an existing fixture instance
 */
export type EditInstanceError = { InvalidData: string } | { Other: string };

/** Represents criteria used to filter an event. For example, a submaster UUID could be used to filter submaster updates by that specific submaster */
export type FilterCriteria = { type: "None" } | { type: "String"; data: string } | { type: "Uuid"; data: Uuid };

/**
 * Importable fixture descriptor bundle that includes output driver-specific information
 */
export interface FixtureBundle {
    fixture_info: FixtureInfo;
    output_info: SerializedData;
}

/**
 * Data type that contains generic, protocol-erased information about a fixture such as name,
 * metadata, personalities, and references to services within the output controller.
 */
export interface FixtureInfo {
    id: Uuid;
    name: string;
    short_name: string | null;
    manufacturer: string | null;
    family: string | null;
    metadata: FixtureMeta;
    channels: Record<string, Channel>;
    personalities: Record<string, Personality>;
    output_driver: string;
}

/**
 * Identifies an individual instance of a fixture
 */
export interface FixtureInstance {
    id: Uuid;
    fixture_id: Uuid;
    personality: string;
    name: string | null;
    comments: string | null;
}

/**
 * Metadata about the fixture, used for display in the UI
 */
export interface FixtureMeta {
    manufacturer: string | null;
    manual_link: string | null;
}

/**
 * Describes a form-style UI using a frontend-agnostic generic data structure
 */
export type FormDescriptor = FormItem[];

/**
 * Describes a dropdown component as part of a form
 */
export interface FormDropdown {
    label: string;
    id: string;
    item_source: FormItemOptionSource;
    value: Value;
}

/**
 * Describes a form element
 */
export type FormItem = { Dynamic: [InteractiveDescription, FormItem[]] } | { Textbox: FormTextbox } | { Number: FormNumber } | { Dropdown: FormDropdown } | { Section: FormSection } | { VerticalStack: FormItem[] } | { HorizontalStack: FormItem[] };

/**
 * Describes a source for dropdown/autocomplete options
 */
export type FormItemOptionSource = { Static: { values: DropdownOptionJSON[] } } | { TypeSpec: { typespec_id: string } };

/**
 * Describes a number input as part of a form
 */
export interface FormNumber {
    label: string;
    id: string;
    validation: NumberValidation;
    value: number | null;
}

/**
 * Describes a visual container for form elements
 */
export interface FormSection {
    label: string;
    form_item: FormItem;
}

/**
 * Describes a textbox as part of a form
 */
export interface FormTextbox {
    label: string;
    id: string;
    value: string | null;
}

/**
 * An error that could occur while retrieving a fixture creation form
 */
export type GetCreationFormError = "FixtureTypeMissing" | { Other: string };

/**
 * An error that could occur while retrieving a fixture edit form
 */
export type GetEditFormError = "FixtureMissing" | "FixtureDefinitionMissing" | "ControllerMissing" | { ControllerError: string };

/** This type is currently undocumented. I will be working to resolve this for all types in the near future. */
export type GetLinkUniverseFormError = { ErrorFromController: string } | "ControllerNotFound";

/**
 * A generic error originating from an OutputDriver interface when importing a fixture definition
 */
export type ImportError = { InvalidData: string } | { Other: string };

/**
 * An error that could occur when importing a fixture definition
 */
export type ImportFixtureError = "UnknownController" | { ErrorFromController: ImportError };

/**
 * Describes a function that can be used to add interactivity to a form
 */
export type InteractiveDescription = { Not: InteractiveDescription } | { And: InteractiveDescription[] } | { Or: InteractiveDescription[] } | { Equal: { field_name: string; value: Value } };

/**
 * An error that could occur while attempting to call a JSON service
 */
export type JSONCallServiceError = { type: "ServiceNotFound" } | { type: "ArgDeserializationFailed" } | { type: "ResponseSerializationFailed" };

/**
 * Describes a command to be sent via a JSON or equivalent API
 */
export type JSONCommand = { type: "CallService"; message_id: number; plugin_id: string; service_id: string; args: Value[] } | { type: "GetServices"; message_id: number } | { type: "GetOptions"; message_id: number; provider_id: string } | { type: "SendEvent"; name: string; criteria: FilterCriteria | null; data: Value } | { type: "Subscribe"; name: string; criteria: FilterCriteria | null } | { type: "Unsubscribe"; name: string; criteria: FilterCriteria | null };

/**
 * Describes an event to be sent to a client via a JSON or equivalent API
 */
export type JSONResponse = { type: "CallServiceResponse"; message_id: number; result: Value } | { type: "ServiceList"; message_id: number; list: ServiceDescription[] } | { type: "OptionsList"; message_id: number; list: { Ok: DropdownOptionJSON[] } | { Err: TypeSpecifierRetrievalError } } | { type: "CallServiceError"; message_id: number; error: JSONCallServiceError } | { type: "Event"; name: string; criteria: FilterCriteria; data: Value };

/**
 * An error that could occur while linking a DMX universe to a universe controller
 */
export type LinkUniverseError = { ErrorFromController: RegisterUniverseError } | "UniverseNotFound" | "ControllerNotFound";

/**
 * Data used by the mixer to blend submasters and produce a final result
 */
export interface MixerContext {
    default_context: MixingContext;
    frozen_context: MixingContext | null;
    blind_opacity: number;
}

/**
 * An error that could occur while initializing the mixer plugin
 */
export type MixerInitializationError = "UnrecognizedData";

/**
 * Describes a single mixer instance, with its own internal state for driving layers and effects
 * 
 * Multiple instances are used for creating a blind mode
 */
export interface MixingContext {
    layer_order: Uuid[];
    layer_opacities: Record<Uuid, number>;
    user_submasters: Record<Uuid, StaticLayer>;
}

/**
 * Describes validation criteria for a number input
 */
export type NumberValidation = "None" | { Not: NumberValidation } | { And: NumberValidation[] } | { Or: NumberValidation[] } | { Between: [number, number] } | { DivisibleBy: number };

/**
 * An error that could occur while initializing the patcher plugin
 */
export type PatcherInitializationError = "UnrecognizedData";

/**
 * Identifies non-implementation-specific features of a personality.
 * 
 * Implementation-specific features of a personality such as channel order should
 * should be stored in the output data for use by the output plugin.
 */
export interface Personality {
    available_channels: string[];
}

/**
 * An error returned when registering a saver. This is usually okay to unwrap, since it should be during init
 */
export type RegisterSavableError = "SaverAlreadyExists";

/**
 * An error that occurs while registering a universe
 */
export type RegisterUniverseError = { InvalidData: string } | { Other: string };

/**
 * An error returned by the saver if saving data failed
 */
export type SaveError = { SaverReturnedErr: { error: string } } | { ErrorSerializing: { error: string } } | "Unsafe";

/**
 * Describes the state of the show controller backend during initialization
 */
export type SaverInitializationStatus = "FinishedSafe" | "FinishedUnsafe" | "Initializing";

/**
 * Identifies a segment used in a segmented channel
 */
export interface Segment {
    start: number;
    end: number;
    name: string;
    id: string;
}

/**
 * Data type used to hold a serialized instance of an arbitrary data type.
 * 
 * This is intended to encapsulate dynamically-typed data intended for deserialization by the output plugin
 */
export type SerializedData = number[] | Value;

/** Describes an argument that must be passed to a service call */
export interface ServiceArgumentOwned {
    id: string;
    name: string;
    description: string;
    val_type: string;
    val_type_hint: string | null;
}

/** Describes a service that can be called from an external API */
export interface ServiceDescription {
    plugin_id: string;
    id: string;
    name: string;
    description: string;
    arguments: ServiceArgumentOwned[];
    returns: ServiceArgumentOwned | null;
}

/**
 * Sharable (and serializable) component of the patcher state containing
 * information about registered fixtures
 */
export interface SharablePatcherState {
    library: Record<Uuid, FixtureInfo>;
    fixture_order: Uuid[];
    fixtures: Record<Uuid, FixtureInstance>;
}

/**
 * Describes an entire show file containing fragments from every plugin
 */
export interface ShowFile {
    plugin_data: Record<string, number[]>;
}

/**
 * This indicates if a value should snap to a new value. This is useful for things like gobos, where
 * intermediate values don't blend, and can instead cause distraction by rapidly switching between noticably
 * discrete states.
 */
export type SnapData = "NoSnap" | { SnapAt: number };

/**
 * Defines a static submaster
 */
export interface StaticLayer {
    values: SubmasterData;
}

/**
 * Represents the data within a submaster used for blending
 */
export type SubmasterData = Record<Uuid, AbstractLayerLight>;

/** Describes an error that occurred while retrieving items for a dropdown list */
export type TypeSpecifierRetrievalError = "SpecifierNotFound" | "SerializationError";

/**
 * This represents a DMX universe instance
 */
export interface UniverseInstance {
    id: Uuid;
    name: string;
    controller: string | null;
}

/** Unique identifier used in various parts of the API. In TS, UUID does not have its own data type, so this just re-exports string. */
export type Uuid = string;

/** Represents Rust's `serde_json::Value` type. This is used for dynamic typing, like when using backend-defined forms. */
export type Value = any;


export const core = {
	log(msg: string): Promise<void> { return callService("core", "log", [msg]) },
	log_error(msg: string): Promise<void> { return callService("core", "log_error", [msg]) },
};

export const mixer = {
	commit_blind(): Promise<void> { return callService("mixer", "commit_blind", []) },
	create_layer(): Promise<Uuid> { return callService("mixer", "create_layer", []) },
	delete_layer(submaster_id: Uuid): Promise<boolean> { return callService("mixer", "delete_layer", [submaster_id]) },
	enter_blind_mode(): Promise<void> { return callService("mixer", "enter_blind_mode", []) },
	get_blind_opacity(): Promise<number | null> { return callService("mixer", "get_blind_opacity", []) },
	get_layer_contents(submaster_id: Uuid): Promise<StaticLayer | null> { return callService("mixer", "get_layer_contents", [submaster_id]) },
	get_layer_opacity(submaster_id: Uuid): Promise<number | null> { return callService("mixer", "get_layer_opacity", [submaster_id]) },
	revert_blind(): Promise<void> { return callService("mixer", "revert_blind", []) },
	set_blind_opacity(opacity: number): Promise<void> { return callService("mixer", "set_blind_opacity", [opacity]) },
	set_layer_contents(submaster_id: Uuid, submaster_delta: SubmasterData): Promise<boolean> { return callService("mixer", "set_layer_contents", [submaster_id, submaster_delta]) },
	set_layer_opacity(submaster_id: Uuid, opacity: number, auto_insert: boolean): Promise<boolean> { return callService("mixer", "set_layer_opacity", [submaster_id, opacity, auto_insert]) },
};

export const output_dmx = {
	create_universe(name: string): Promise<Uuid> { return callService("output_dmx", "create_universe", [name]) },
	delete_universe(universe_id: Uuid): Promise<void> { return callService("output_dmx", "delete_universe", [universe_id]) },
	get_link_universe_form(driver_id: string, universe_id: Uuid | null): Promise<{ Ok: FormDescriptor } | { Err: GetLinkUniverseFormError }> { return callService("output_dmx", "get_link_universe_form", [driver_id, universe_id]) },
	get_linked_controller(universe_id: Uuid): Promise<string | null> { return callService("output_dmx", "get_linked_controller", [universe_id]) },
	link_universe(universe_id: Uuid, driver: string, form_data: SerializedData): Promise<{ Ok: null } | { Err: LinkUniverseError }> { return callService("output_dmx", "link_universe", [universe_id, driver, form_data]) },
	list_drivers(): Promise<DMXDriverDescription[]> { return callService("output_dmx", "list_drivers", []) },
	list_universes(): Promise<[Uuid, string][]> { return callService("output_dmx", "list_universes", []) },
	unlink_universe(universe_id: Uuid): Promise<void> { return callService("output_dmx", "unlink_universe", [universe_id]) },
};

export const patcher = {
	create_fixture(fixture_type: Uuid, personality: string, name: string | null, comments: string | null, form_data: SerializedData): Promise<{ Ok: Uuid } | { Err: CreateFixtureError }> { return callService("patcher", "create_fixture", [fixture_type, personality, name, comments, form_data]) },
	edit_fixture(instance_id: Uuid, personality: string, name: string | null, comments: string | null, form_data: SerializedData): Promise<{ Ok: null } | { Err: EditFixtureError }> { return callService("patcher", "edit_fixture", [instance_id, personality, name, comments, form_data]) },
	get_creation_form(fixture_type: Uuid): Promise<{ Ok: FormDescriptor } | { Err: GetCreationFormError }> { return callService("patcher", "get_creation_form", [fixture_type]) },
	get_edit_form(fixture_id: Uuid): Promise<{ Ok: FormDescriptor } | { Err: GetEditFormError }> { return callService("patcher", "get_edit_form", [fixture_id]) },
	get_patcher_state(): Promise<SharablePatcherState> { return callService("patcher", "get_patcher_state", []) },
	import_fixture(fixture_bundle: FixtureBundle): Promise<{ Ok: null } | { Err: ImportFixtureError }> { return callService("patcher", "import_fixture", [fixture_bundle]) },
};

export const saver = {
	save(): Promise<{ Ok: number[] } | { Err: SaveError }> { return callService("saver", "save", []) },
};

